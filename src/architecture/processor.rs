use crate::architecture::opcodes::OpCode;
use crate::architecture::opcodes::OpCode::*;
use crate::architecture::state::State;
use crate::architecture::instructions::*;
use crate::architecture::instruction::Instruction;

pub fn determine_processing_unit(opcode: &OpCode) -> fn(&mut State, &Instruction) -> bool {
    match opcode {
        NOP => nop::no_operation,
        LXI => immediate::load_register_pair,
        STAX => data_transfer::store_accumulator,
        INX => double_register::increment,
        INR => single_register::increment,
        DCR => single_register::decrement,
        MVI => immediate::move_data,
        RLC => rotate_accumulator::rotate_left,
        DAD => double_register::double_add,
        LDAX => data_transfer::load_accumulator,
        DCX => double_register::decrement,
        RRC => rotate_accumulator::rotate_right,
        RAL => rotate_accumulator::rotate_left_through_carry,
        RAR => rotate_accumulator::rotate_right_through_carry,
        SHLD => direct_addressing::store_hl,
        DAA => single_register::decimal_adjust_accumulator,
        LHLD => direct_addressing::load_hl,
        CMA => single_register::complement_accumulator,
        STA => direct_addressing::store_accumulator,
        STC => carry_bit::set,
        LDA => direct_addressing::load_accumulator,
        CMC => carry_bit::complement,
        MOV => data_transfer::move_reg,
        HLT => hlt::halt,
        ADD => to_accumulator::add,
        ADC => to_accumulator::add_with_carry,
        SUB => to_accumulator::sub,
        SBB => to_accumulator::sub_with_borrow,
        ANA => to_accumulator::logical_and,
        XRA => to_accumulator::logical_xor,
        ORA => to_accumulator::logical_or,
        CMP => to_accumulator::compare,
        RNZ => returns::no_zero,
        POP => double_register::pop,
        JNZ => jump::no_zero,
        JMP => jump::default,
        CNZ => call::no_zero,
        PUSH => double_register::push,
        ADI => immediate::add,
        RST => rst::restart,
        RZ => returns::zero,
        RET => returns::default,
        JZ => jump::zero,
        CZ => call::zero,
        CALL => call::default,
        ACI => immediate::add_with_carry,
        RNC => returns::no_carry,
        JNC => jump::no_carry,
        OUT => io::output,
        CNC => call::no_carry,
        SUI => immediate::sub,
        RC => returns::carry,
        JC => jump::carry,
        IN => io::input,
        CC => call::carry,
        SBI => immediate::sub_with_borrow,
        RPO => returns::parity_odd,
        JPO => jump::parity_odd,
        XTHL => double_register::exchange_sp,
        CPO => call::parity_odd,
        ANI => immediate::and,
        RPE => returns::parity_even,
        PCHL => jump::load_pc,
        JPE => jump::parity_even,
        XCHG => double_register::exchange,
        CPE => call::parity_even,
        XRI => immediate::xor,
        RP => returns::positive,
        JP => jump::positive,
        DI => interrupt::disable,
        CP => call::positive,
        ORI => immediate::or,
        RM => returns::minus,
        SPHL => double_register::load_sp_from_hl,
        JM => jump::minus,
        EI => interrupt::enable,
        CM => call::minus,
        CPI => immediate::compare,
    }
}